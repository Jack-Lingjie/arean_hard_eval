**Gaussian Blur Metal Compute Kernel**

The following Metal compute kernel applies a Gaussian blur to an image. This kernel uses a 2D convolution approach to achieve the blur effect.

### Gaussian Blur Kernel

```metal
#include <metal_stdlib>

using namespace metal;

// Structure to hold image data
struct Image {
    texture2d<float, access::sample> texture [[texture(0)]];
};

// Structure to hold kernel parameters
struct KernelParams {
    float radius;
    float sigma;
};

// Kernel function
kernel void gaussianBlur(
    device Image& image [[buffer(0)]],
    device KernelParams& params [[buffer(1)]],
    device float* output [[buffer(2)]],
    uint2 gid [[thread_position_in_grid]])
{
    // Calculate the radius for the kernel
    float radius = params.radius;
    
    // Calculate the sigma value for the kernel
    float sigma = params.sigma;
    
    // Get the texture dimensions
    uint width = image.texture.get_width();
    uint height = image.texture.get_height();
    
    // Check if the current thread is within the image bounds
    if (gid.x < width && gid.y < height) {
        // Initialize the output pixel value
        float4 outputPixel = float4(0.0);
        
        // Apply the Gaussian blur kernel
        for (int x = -int(radius); x <= int(radius); x++) {
            for (int y = -int(radius); y <= int(radius); y++) {
                // Calculate the kernel coordinates
                uint2 kernelCoord = uint2(gid.x + x, gid.y + y);
                
                // Check if the kernel coordinates are within the image bounds
                if (kernelCoord.x >= 0 && kernelCoord.x < width && kernelCoord.y >= 0 && kernelCoord.y < height) {
                    // Sample the texture at the kernel coordinates
                    float4 sample = image.texture.sample(sampler_state, float2(float(kernelCoord.x), float(kernelCoord.y)));
                    
                    // Calculate the kernel weight
                    float weight = exp(-((x * x) + (y * y)) / (2 * (sigma * sigma)));
                    
                    // Add the weighted sample to the output pixel
                    outputPixel += sample * weight;
                }
            }
        }
        
        // Store the output pixel value
        output[gid.x + width * gid.y] = outputPixel.rgb;
    }
}
```

### Explanation

- **Kernel Function**: The `gaussianBlur` kernel function applies a Gaussian blur to an image.
- **Parameters**: The kernel takes three parameters:
  - `image`: A structure containing the input image texture.
  - `params`: A structure containing the kernel parameters (`radius` and `sigma`).
  - `output`: A buffer to store the output pixel values.
- **Thread Position**: The `gid` variable represents the position of the current thread within the grid.
- **Kernel Coordinates**: The kernel coordinates are calculated based on the radius and sigma values.
- **Weighted Sampling**: The kernel samples the texture at the kernel coordinates and calculates the kernel weight based on the sigma value.
- **Output Pixel**: The weighted sample is added to the output pixel value.

### Example Use Case

To use this kernel, you would:

1. **Create a Metal Compute Pipeline**: Create a Metal compute pipeline with the `gaussianBlur` kernel.
2. **Set Up the Kernel Parameters**: Set up the kernel parameters (`radius` and `sigma`) based on your requirements.
3. **Run the Kernel**: Run the kernel on the input image texture.

This kernel applies a Gaussian blur to an image using a 2D convolution approach. The `radius` and `sigma` parameters control the blur effect.