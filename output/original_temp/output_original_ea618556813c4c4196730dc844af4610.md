**Perl Script for Video Reencoding**

This script performs video reencoding using `av1an` and `ffmpeg`. It takes command-line arguments to customize the reencoding process.

### Script

```perl
#!/usr/bin/perl

use strict;
use warnings;

# Get the script's directory
my $dir = (File::Spec->rel2abs($0))[1];

# Source the video.sh file
do "$dir/../video.sh";

# Initialize variables
my $quality = "";
my $preset = "";
my $resize = "";
my $noise = "";
my $input_file = "";

# Parse command-line arguments
while (@ARGV) {
    my $arg = shift @ARGV;
    if ($arg eq "-q" || $arg eq "--quality") {
        $quality = shift @ARGV;
    } elsif ($arg eq "-p" || $arg eq "--preset") {
        $preset = shift @ARGV;
    } elsif ($arg eq "-r" || $arg eq "--resize") {
        $resize = shift @ARGV;
    } elsif ($arg eq "-n" || $arg eq "--noise") {
        $noise = shift @ARGV;
    } else {
        $input_file = $arg;
    }
}

# Check if the input file exists
if (! -f $input_file) {
    print "FILE NOT FOUND: $input_file\n";
    exit 1;
}

# Check for required arguments
if (!$quality || !$preset || !$input_file) {
    print "Usage: $0 -q|--quality <quality> -p|--preset <preset> [-n|--noise <noise_level>] [-r|--resize <size>] <input_file>\n";
    exit 1;
}

# Get the file path and name
my $file_path = File::Spec->rel2abs($input_file);
my $file_name = get_filename($file_path);

# Set the chunk method
my $chunk_method = "ffms2";

# Create the output file name
my $output_name = "${file_name}.reencode.av1an.aom.rf${quality}.p${preset}";
my $metadata_comment = "reencoded with av1an(aom), 10-bit, cpu-used=${preset}, cq=${quality}, chunk-method=$chunk_method";

# Add noise and resize to the output file name if specified
if ($noise) {
    $output_name .= ".noise${noise}";
} else {
    $noise = 10;
}
if ($resize) {
    $output_name .= ".${resize}p";
}

# Run av1an
my $threads = 2;
ulimit -n 2048;
av1an --verbose
    -i "$file_path"
    --encoder aom
    --workers 4
    --resume
    --extra-split 300
    --ignore-frame-mismatch
    --audio-params " -an "
    --ffmpeg " -an $([[ -n $resize ]] && " -vf 'scale=-1:${resize}'")"
    --split-method av-scenechange --chunk-method $chunk_method --concat mkvmerge
    --set-thread-affinity="$threads"
    --photon-noise="$noise"
    --video-params " \
        --bit-depth=10 \
        --threads=$threads \
        --end-usage=q --cq-level=$quality --cpu-used=$preset \
        --tile-columns=0 --tile-rows=0 \
        --tune-content=psy --tune=ssim \
        --lag-in-frames=64 \
        --enable-keyframe-filtering=1 --disable-kf --kf-max-dist=9999 \
        --enable-qm=1 --deltaq-mode=0 --aq-mode=0 --quant-b-adapt=1 \
        --enable-fwd-kf=0 --arnr-strength=4 --sb-size=dynamic --enable-dnl-denoising=0 \
    "
    -o "${output_name}.audioless.mkv";

# Add audio and convert to MP4
my $ffmpeg_cmd = "ffmpeg -loglevel warning -hide_banner -i '${output_name}.audioless.mkv' -i '$file_path' -c copy -map 0:v -map 1:a -metadata comment='$metadata_comment' '${output_name}.mp4'";
system($ffmpeg_cmd);

# Remove temporary files
rm -rf "${output_name}.audioless.mkv";

# Display file information
print "\n\n";
exa -al --color=always --no-permissions --no-user --time-style=long-iso "$input_file" "${output_name}.mp4";

# Compare video files
print "video-compare \"$input_file\" \"${output_name}.mp4\"\n";

# Display completion message
print "\nâœ… FINISHED\n";
```

### Usage

To use this script, save it to a file (e.g., `reencode_video.pl`), make the file executable with `chmod +x reencode_video.pl`, and then run it with the desired arguments:

```bash
./reencode_video.pl -q <quality> -p <preset> [-n <noise_level>] [-r <size>] <input_file>
```

Replace `<quality>`, `<preset>`, `<noise_level>`, `<size>`, and `<input_file>` with the actual values for your reencoding process.