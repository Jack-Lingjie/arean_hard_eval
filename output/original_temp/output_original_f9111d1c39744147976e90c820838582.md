**Data Storage Oriented Blockchain Implementation**

### Overview

This Python program implements a data storage oriented blockchain that rewards node owners for hosting data. The system charges deposit fees based on data size and lifetime. Nodes can increase their storage deposit to extend data lifetime and take fees from other nodes for accessing stored data.

### Code

```python
import hashlib
import time
import random

class Node:
    def __init__(self, node_id):
        self.node_id = node_id
        self.balance = 0
        self.stored_data = {}

class Block:
    def __init__(self, index, previous_hash, timestamp, data, node_id):
        self.index = index
        self.previous_hash = previous_hash
        self.timestamp = timestamp
        self.data = data
        self.node_id = node_id

class Blockchain:
    def __init__(self):
        self.chain = [self.create_genesis_block()]
        self.nodes = {}

    def create_genesis_block(self):
        return Block(0, "0", time.time(), "Genesis Block", "Genesis Node")

    def add_block(self, data, node_id):
        previous_block = self.chain[-1]
        new_block = Block(len(self.chain), previous_block.hash, time.time(), data, node_id)
        self.chain.append(new_block)
        self.update_node_balance(node_id, data)

    def update_node_balance(self, node_id, data):
        data_size = len(data)
        data_lifetime = self.get_data_lifetime(data)
        deposit_amount = self.calculate_deposit(data_size, data_lifetime)
        self.nodes[node_id].balance += deposit_amount
        self.distribute_deposit(node_id, data)

    def calculate_deposit(self, data_size, data_lifetime):
        # Deposit amount varies based on data size and lifetime
        return data_size * data_lifetime

    def distribute_deposit(self, node_id, data):
        # Distribute deposited amount evenly across all nodes hosting the data
        for node in self.nodes:
            if node != node_id and data in self.nodes[node].stored_data:
                self.nodes[node].balance += self.nodes[node_id].balance // len(self.nodes)

    def get_data_lifetime(self, data):
        # Data lifetime can be either in time or in blocks
        return random.randint(1, 100)  # Example: random lifetime in blocks

    def delete_data(self, node_id, data):
        # Node can delete their data from the blockchain
        if data in self.nodes[node_id].stored_data:
            self.nodes[node_id].balance += self.nodes[node_id].stored_data[data]
            del self.nodes[node_id].stored_data[data]
            for node in self.nodes:
                if data in self.nodes[node].stored_data:
                    del self.nodes[node].stored_data[data]

    def access_data(self, node_id, data):
        # Node takes fees from other nodes for accessing stored data
        if data in self.nodes[node_id].stored_data:
            fee = self.calculate_fee(data)
            self.nodes[node_id].balance += fee
            return fee
        return 0

    def calculate_fee(self, data):
        # Fee calculation based on data size and lifetime
        return len(data) * self.get_data_lifetime(data)

# Example usage
blockchain = Blockchain()

# Create nodes
node1 = Node("Node1")
node2 = Node("Node2")
blockchain.nodes[node1.node_id] = node1
blockchain.nodes[node2.node_id] = node2

# Add data to the blockchain
data = b"Example data"
blockchain.add_block(data, node1.node_id)

# Access stored data
fee = blockchain.access_data(node2.node_id, data)
print(f"Fee: {fee}")

# Delete data from the blockchain
blockchain.delete_data(node1.node_id, data)

# Print node balances
print(f"Node1 balance: {blockchain.nodes['Node1'].balance}")
print(f"Node2 balance: {blockchain.nodes['Node2'].balance}")
```

### Explanation

This implementation includes:

1.  **Node Class**: Represents a node in the network, with attributes for node ID, balance, and stored data.
2.  **Block Class**: Represents a block in the blockchain, containing index, previous hash, timestamp, data, and node ID.
3.  **Blockchain Class**: Manages the blockchain, including creating genesis blocks, adding new blocks, updating node balances, distributing deposits, and deleting data.

**Key Features:**

*   **Data Storage Deposit**: Nodes deposit coins to add data to the blockchain, with the deposit amount varying based on data size and lifetime.
*   **Deposit Distribution**: Deposited amounts are distributed evenly across all nodes hosting the data until its lifetime expires.
*   **Data Access Fees**: Nodes take fees from other nodes for accessing stored data.
*   **Data Deletion**: Nodes can delete their data from the blockchain, and the original data uploader receives their unused data storage deposit back.

**Example Usage:**

The code demonstrates how to create nodes, add data to the blockchain, access stored data, and delete data. It also prints the node balances after these operations.