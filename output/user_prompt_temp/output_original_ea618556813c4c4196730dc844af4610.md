<|User Prompt|>
please rewrite this bash script in perl, keeping the same functionality (reading arguments passed to the script), and also calling the same executables like the original (ffmpeg, rm, av1an)

#!/bin/bash
set -euo pipefail

DIR="$(dirname -- "$(readlink -f -- "$0")")"
source "$DIR/../video.sh"

# Initialize variables with default values
quality=""
preset=""
resize=""
noise=""
input_file=""

# Loop through the command-line arguments
while [[ $# -gt 0 ]]; do
  case $1 in
  -q | --quality)
    quality="$2"
    shift 2
    ;;
  -p | --preset)
    preset="$2"
    shift 2
    ;;
  -r | --resize)
    resize="$2"
    shift 2
    ;;
  -n | --noise)
    noise="$2"
    shift 2
    ;;
  *)
    input_file="$1"
    shift
    ;;
  esac
done

if [[ ! -f "$input_file" ]]; then
  echo "FILE NOT FOUND: $input_file"
fi

# Check for required arguments
if [[ -z $quality ]] || [[ -z $preset ]] || [[ -z $input_file ]]; then
  echo "Usage: $0 -q|--quality <quality> -p|--preset <preset> [-n|--noise <noise_level>] [-r|--resize <size>] <input_file>"
  exit 1
fi

file_path=$(readlink -f "$input_file")
file_name=$(get-filename "$file_path")

chunk_method="ffms2"

output_name="${file_name}.reencode.av1an.aom.rf${quality}.p${preset}"
metadata_comment="reencoded with av1an(aom), 10-bit, cpu-used=${preset}, cq=${quality}, chunk-method=$chunk_method"

if [ -n "$noise" ]; then
  output_name+=".noise${noise}"
else
  noise=10
fi

if [ -n "$resize" ]; then
  output_name+=".${resize}p"
fi

# Supposedtly to work without L-SMASH:
#    av1an -i "input" -y --resume --verbose --split-method av-scenechange -m hybrid -c mkvmerge -e rav1e --force -v " --tiles 8 -s 4 --quantizer 80 --no-scene-detection" --photon-noise 7 --chroma-noise --pix-format yuv420p10le -w 8 -o "output.mkv"

# --disable-kf --enable-fwd-kf=0 We're disabling keyframes cause Av1an already did scene detection, so we wont have to.. And it speeds things up.
# --kf-max-dist=9999 Maximum keyframe interval, we're setting it at the highest possible value since av1an's scene detection keyframe interval is already 240 by default
# --enable-chroma-deltaq=1 --enable-qm=1 --quant-b-adapt=1 Parameters that give you free efficiency boost, ignore it.

# --ffmpeg "-vf 'scale=-1:720'" \
# --concat mkvmerge --chunk-method ffms2 \

# --workers 4 --set-thread-affinity=2  \  #does not seem to work on OSX, remember to also set --threads of the --video params to the same value as thread affinity
# --photon-noise=10 \     # for grain synthesis
# --chunk-method lsmash
# --sc-method fast --sc-downscale-height 320 \

ulimit -n 2048

threads=2

av1an --verbose \
  -i "$file_path" \
  --encoder aom \
  --workers 4 \
  --resume \
  --extra-split 300 \
  --ignore-frame-mismatch \
  --audio-params " -an " \
  --ffmpeg " -an $([[ -n "$resize" ]] && echo " -vf 'scale=-1:${resize}'")" \
  --split-method av-scenechange --chunk-method $chunk_method --concat mkvmerge \
  --set-thread-affinity="$threads" \
  --photon-noise="$noise" \
  --video-params " \
    --bit-depth=10 \
    --threads=$threads \
    --end-usage=q --cq-level=$quality --cpu-used=$preset \
    --tile-columns=0 --tile-rows=0 \
    --tune-content=psy --tune=ssim \
    --lag-in-frames=64 \
    --enable-keyframe-filtering=1 --disable-kf --kf-max-dist=9999 \
    --enable-qm=1 --deltaq-mode=0 --aq-mode=0 --quant-b-adapt=1 \
    --enable-fwd-kf=0 --arnr-strength=4 --sb-size=dynamic --enable-dnl-denoising=0 \
    " \
  -o "${output_name}.audioless.mkv"

# put the audio back and convert to mp4
ffmpeg -loglevel warning -hide_banner \
  -i "${output_name}.audioless.mkv" -i "$file_path" \
  -c copy -map 0:v -map 1:a \
  -metadata comment="$metadata_comment" \
  "${output_name}.mp4"

rm -rf "${output_name}.audioless.mkv"

echo -e "\n\n"
exa -al --color=always --no-permissions --no-user --time-style=long-iso "$input_file" "${output_name}.mp4"

echo ""
echo "video-compare \"$input_file\" \"${output_name}.mp4\""

echo -e "\n✅ FINISHED"


<|The Start of Assistant A's Answer|>
```perl
#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Cwd 'abs_path';
use File::Basename;

my $dir = dirname(abs_path($0));
require "$dir/../video.sh";

my ($quality, $preset, $resize, $noise, $input_file);

GetOptions(
    "quality|q=s" => \$quality,
    "preset|p=s"  => \$preset,
    "resize|r=s"  => \$resize,
    "noise|n=s"   => \$noise,
    "<>"          => sub { $input_file = $_[0] },
);

die "FILE NOT FOUND: $input_file" if !-f $input_file;

if (!defined $quality || !defined $preset || !defined $input_file) {
    die "Usage: $0 -q|--quality <quality> -p|--preset <preset> [-n|--noise <noise_level>] [-r|--resize <size>] <input_file>";
}

my $file_path = abs_path($input_file);
my $file_name = get_filename($file_path);

my $chunk_method = "ffms2";

my $output_name = "${file_name}.reencode.av1an.aom.rf${quality}.p${preset}";
my $metadata_comment = "reencoded with av1an(aom), 10-bit, cpu-used=${preset}, cq=${quality}, chunk-method=$chunk_method";

if (defined $noise) {
    $output_name .= ".noise${noise}";
} else {
    $noise = 10;
}

if (defined $resize) {
    $output_name .= ".${resize}p";
}

$ENV{ULIMIT} = 2048;

my $threads = 2;

my $av1an_command = "av1an --verbose "
  . "-i \"$file_path\" "
  . "--encoder aom "
  . "--workers 4 "
  . "--resume "
  . "--extra-split 300 "
  . "--ignore-frame-mismatch "
  . "--audio-params \" -an \" "
  . "--ffmpeg \" -an " . (defined $resize ? " -vf 'scale=-1:${resize}'" : "") . "\" "
  . "--split-method av-scenechange --chunk-method $chunk_method --concat mkvmerge "
  . "--set-thread-affinity=\"$threads\" "
  . "--photon-noise=\"$noise\" "
  . "--video-params \" "
    . "--bit-depth=10 "
    . "--threads=$threads "
    . "--end-usage=q --cq-level=$quality --cpu-used=$preset "
    . "--tile-columns=0 --tile-rows=0 "
    . "--tune-content=psy --tune=ssim "
    . "--lag-in-frames=64 "
    . "--enable-keyframe-filtering=1 --disable-kf --kf-max-dist=9999 "
    . "--enable-qm=1 --deltaq-mode=0 --aq-mode=0 --quant-b-adapt=1 "
    . "--enable-fwd-kf=0 --arnr-strength=4 --sb-size=dynamic --enable-dnl-denoising=0 "
    . "\" "
  . "-o \"${output_name}.audioless.mkv\"";

system($av1an_command);

my $ffmpeg_command = "ffmpeg -loglevel warning -hide_banner "
  . "-i \"${output_name}.audioless.mkv\" -i \"$file_path\" "
  . "-c copy -map 0:v -map 1:a "
  . "-metadata comment=\"$metadata_comment\" "
  . "\"${output_name}.mp4\"";

system($ffmpeg_command);

unlink "${output_name}.audioless.mkv";

print "\n\n";
system("exa -al --color=always --no-permissions --no-user --time-style=long-iso \"$input_file\" \"${output_name}.mp4\"");

print "\n";
print "video-compare \"$input_file\" \"${output_name}.mp4\"";

print "\n✅ FINISHED\n";
```

<|The End of Assistant A's Answer|>

<|The Start of Assistant B's Answer|>
**Perl Script for Video Reencoding**

This script performs video reencoding using `av1an` and `ffmpeg`. It takes command-line arguments to customize the reencoding process.

### Script

```perl
#!/usr/bin/perl

use strict;
use warnings;

# Get the script's directory
my $dir = (File::Spec->rel2abs($0))[1];

# Source the video.sh file
do "$dir/../video.sh";

# Initialize variables
my $quality = "";
my $preset = "";
my $resize = "";
my $noise = "";
my $input_file = "";

# Parse command-line arguments
while (@ARGV) {
    my $arg = shift @ARGV;
    if ($arg eq "-q" || $arg eq "--quality") {
        $quality = shift @ARGV;
    } elsif ($arg eq "-p" || $arg eq "--preset") {
        $preset = shift @ARGV;
    } elsif ($arg eq "-r" || $arg eq "--resize") {
        $resize = shift @ARGV;
    } elsif ($arg eq "-n" || $arg eq "--noise") {
        $noise = shift @ARGV;
    } else {
        $input_file = $arg;
    }
}

# Check if the input file exists
if (! -f $input_file) {
    print "FILE NOT FOUND: $input_file\n";
    exit 1;
}

# Check for required arguments
if (!$quality || !$preset || !$input_file) {
    print "Usage: $0 -q|--quality <quality> -p|--preset <preset> [-n|--noise <noise_level>] [-r|--resize <size>] <input_file>\n";
    exit 1;
}

# Get the file path and name
my $file_path = File::Spec->rel2abs($input_file);
my $file_name = get_filename($file_path);

# Set the chunk method
my $chunk_method = "ffms2";

# Create the output file name
my $output_name = "${file_name}.reencode.av1an.aom.rf${quality}.p${preset}";
my $metadata_comment = "reencoded with av1an(aom), 10-bit, cpu-used=${preset}, cq=${quality}, chunk-method=$chunk_method";

# Add noise and resize to the output file name if specified
if ($noise) {
    $output_name .= ".noise${noise}";
} else {
    $noise = 10;
}
if ($resize) {
    $output_name .= ".${resize}p";
}

# Run av1an
my $threads = 2;
ulimit -n 2048;
av1an --verbose
    -i "$file_path"
    --encoder aom
    --workers 4
    --resume
    --extra-split 300
    --ignore-frame-mismatch
    --audio-params " -an "
    --ffmpeg " -an $([[ -n $resize ]] && " -vf 'scale=-1:${resize}'")"
    --split-method av-scenechange --chunk-method $chunk_method --concat mkvmerge
    --set-thread-affinity="$threads"
    --photon-noise="$noise"
    --video-params " \
        --bit-depth=10 \
        --threads=$threads \
        --end-usage=q --cq-level=$quality --cpu-used=$preset \
        --tile-columns=0 --tile-rows=0 \
        --tune-content=psy --tune=ssim \
        --lag-in-frames=64 \
        --enable-keyframe-filtering=1 --disable-kf --kf-max-dist=9999 \
        --enable-qm=1 --deltaq-mode=0 --aq-mode=0 --quant-b-adapt=1 \
        --enable-fwd-kf=0 --arnr-strength=4 --sb-size=dynamic --enable-dnl-denoising=0 \
    "
    -o "${output_name}.audioless.mkv";

# Add audio and convert to MP4
my $ffmpeg_cmd = "ffmpeg -loglevel warning -hide_banner -i '${output_name}.audioless.mkv' -i '$file_path' -c copy -map 0:v -map 1:a -metadata comment='$metadata_comment' '${output_name}.mp4'";
system($ffmpeg_cmd);

# Remove temporary files
rm -rf "${output_name}.audioless.mkv";

# Display file information
print "\n\n";
exa -al --color=always --no-permissions --no-user --time-style=long-iso "$input_file" "${output_name}.mp4";

# Compare video files
print "video-compare \"$input_file\" \"${output_name}.mp4\"\n";

# Display completion message
print "\n✅ FINISHED\n";
```

### Usage

To use this script, save it to a file (e.g., `reencode_video.pl`), make the file executable with `chmod +x reencode_video.pl`, and then run it with the desired arguments:

```bash
./reencode_video.pl -q <quality> -p <preset> [-n <noise_level>] [-r <size>] <input_file>
```

Replace `<quality>`, `<preset>`, `<noise_level>`, `<size>`, and `<input_file>` with the actual values for your reencoding process.
<|The End of Assistant B's Answer|>